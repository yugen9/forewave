## 1.1 数据结构

### 1.1.1 Build-in

### 1.1.2 链表Linklist[^1]

链表是实现了数据之间保持逻辑顺序，但存储空间不必按顺序的方法。可以用一个图来表示这种链表的数据结构：

[<img src="https://zhaochj.github.io/images/2016-05-13-01.jpg" alt="链表" style="zoom:67%;" />](https://zhaochj.github.io/images/2016-05-13-01.jpg)

**基本要素：**

1. 结点(也可以叫节点或元素)，每一个结点有两个域，左边部份叫`值域`，用于存放用户数据；右边叫`指针域`，一般是存储着到下一个元素的指针
2. head结点，head是一个特殊的结节，head结点永远指向第一个结点
3. tail结点，tail结点也是一个特殊的结点，tail结点永远指向最后一个节点
4. None，链表中最后一个结点指针域的指针指向None值，因也叫`接地点`，所以有些资料上用电气上的接地符号代表None

**常用方法：**

1. LinkedList()           创建空链表，不需要参数，返回值是空链表
2. is_empty()             测试链表是否为空，不需要参数，返回值是布尔值
3. append(data)        在尾部增加一个元素作为列表最后一个。参数是要追加的元素，无返回值
4. iter()                       遍历链表，无参数，无返回值，此方法一般是一个生成器
5. insert(idx,value)   插入一个元素，参数为插入元素的索引和值
6. remove(idx)          移除1个元素，参数为要移除的元素或索引，并修改链表
7. size()                      返回链表的元素数，不需要参数，返回值是个整数
8. search(item)         查找链表某元素，参数为要查找的元素或索引，返回是布尔值

**链表种类：**单向链表、单向循环链表、双向链表、双向循环链表

​                  ![img](https://img-blog.csdn.net/20180721154905692?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzcyODAzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 节点类

python用类来实现链表的数据结构，节点（Node）是实现链表的基本模块，每个节点至少包括两个重要部分。首先，包括节点自身的数据，称为“数据域”(也叫值域)。其次，每个节点包括下一个节点的“引用”(也叫指针)

实现一个Node类：

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
```

此节点类只有一个构建函数，接收一个数据参数，其中`next`表示指针域的指针，实例化后得到一个节点对象，如下：

```
node = Node(4)
```

此节点对象数据为`4`，指针指向None。

这样一个节点对象可以用一个图例来更形象的说明，如下：

<img src="https://zhaochj.github.io/images/2016-05-13-02.jpg" alt="链表" style="zoom:67%;" />  

#### 链表类

LinkedList类的构建函数：

```python
class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
```

此类实例后会生成一个链表对象，初始化了`head`和`tail`节点，且两节点都指向`None`，实例化代码如下：

```python
link_list = LinkedList()
```

也可以用图形象的表示这个链表对象，如下：

[<img src="https://zhaochj.github.io/images/2016-05-13-03.jpg" alt="链表" style="zoom:67%;" />](https://zhaochj.github.io/images/2016-05-13-03.jpg)
　　　　　　　　　　　　　　　

##### is_empty方法实现

is_empty方法检查链表是否是一个空链表，这个方法只需要检查`head`节点是否指向`None`即可，代码如下：

```python
def is_empty(self):
        return self.head is None
```

如果是空列表返回`True`，否则返回`False`

##### append方法实现

append方法表示增加元素到链表，这和insert方法不同，前者使新增加的元素成为链表中第一个节点，而后者是根据索引值来判断插入到链表的哪个位置。代码如下：

```python
def append(self, data):
        node = Node(data)
        if self.head is None:
            self.head = node
            self.tail = node
        else:
            self.tail.next = node
            self.tail = node
```

既然要新增加节点，首先把Node类实例化得到一个node对象。这里有两种情况需要考虑，一是链表是一个空链表时怎样append一个节点；二是当链表不是空链表时又怎样append一个节点？

当`if self.head is None:`为`True`时，把链表的`head`和`tail`都指向了`node`，假如我们执行了

```
link_list(append(4))
```

此时的链表结构如下图：

[<img src="https://zhaochj.github.io/images/2016-05-13-04.jpg" alt="链表" style="zoom:67%;" />](https://zhaochj.github.io/images/2016-05-13-04.jpg)

当`if self.head is None:`为`False`时,说明链表已经增加了一个节点了，再增加一个节点时`head`已经指向了第一个节点，所以不为`None`，比如增加的第二个节点为：

```
link_list(append(5))
```

增加第二个节点的操作需要分两步完成，第一步：`self.tail.next = node`，即把上一个节点的`next`指针指向当前`node`；第二步：`self.tail = node`，把`tail`移动到`node`，如下图：

[<img src="https://zhaochj.github.io/images/2016-05-13-05.jpg" alt="链表" style="zoom:67%;" />](https://zhaochj.github.io/images/2016-05-13-05.jpg)

移动完成后就成这样了：

[<img src="https://zhaochj.github.io/images/2016-05-13-06.jpg" alt="链表" style="zoom:67%;" />](https://zhaochj.github.io/images/2016-05-13-06.jpg)

当增加第三个、第四个等节点时，按照上边的操作依次类推。

##### iter方法实现

iter方法表示遍历链表。在遍历链表时也要首先考虑空链表的情况。遍历链表时从`head`开始，直到一个节点的`next`指向`None`结束，代码如下：

```python
def iter(self):
        if not self.head:
            return
        cur = self.head
        yield cur.data
        while cur.next:
            cur = cur.next
            yield cur.data
```

当是遍历一个空链表时，`if not self.head:`为`True`，直接返回`None`；如果不是空链表就让一个局部变量`cur`指向`head`,并把`head`的`data`属性`yield`出来，再对`cur`的`next`指针指向的对象做`while`循环，直到`next`指向`None`，这样就遍历了链表。

##### insert方法实现

假如采取`append`方法又增加了两个节点，增加完成后如下图：

[<img src="https://zhaochj.github.io/images/2016-05-13-07.jpg" alt="链表" style="zoom:67%;" />](https://zhaochj.github.io/images/2016-05-13-07.jpg)

如果想在数据域为`6`的那节点处插入一个节点，需要做的操作有两步：

1. 把新节点的next指针指向数据域为`6`的这个节点，即为数据域为`5`节点的next指向指向的对象
2. 把数据域为`5`节点的next指针指向新加的节点

注： 这两个步骤不能颠倒，如果颠倒，数据域为`6`的节点会被丢失，数据域为`7`的节点不再是链表的节点。

示意图如下：

[<img src="https://zhaochj.github.io/images/2016-05-13-08.jpg" alt="链表" style="zoom:67%;" />](https://zhaochj.github.io/images/2016-05-13-08.jpg)

还要额外考虑两种情况：

1. 空链表时
2. 插入位置超出链表节点的长度时
3. 插入位置是链表的最后一个节点时，需要移动tail

当是在链表最后一个节点插入时，示意图如下：

[<img src="https://zhaochj.github.io/images/2016-05-13-09.jpg" alt="链表" style="zoom:67%;" />](https://zhaochj.github.io/images/2016-05-13-09.jpg)

要在指定的索引位置插入一个节点，前提是需要找到这个位置，在链表中只有采用遍历的方式，具有O(n)的速度，最糟糕时会遍历链表的所有节点，而当找到插入点时，我们并不需要当前节点的信息，而是需要前一个节点的信息，所以代码中巧妙的使用了`while cur_idx < idx-1:`的方式，这样能使用`cur`这个变量能指向插入点上一个节点对象。

实现`insert`方法的代码如下：

```python
def insert(self, idx, value):
        cur = self.head
        cur_idx = 0
        if cur is None:
            raise Exception('The list is an empty list')
        while cur_idx < idx-1:
            cur = cur.next
            if cur is None:
                raise Exception('list length less than index')
            cur_idx += 1
        node = Node(value)
        node.next = cur.next
        cur.next = node
        if node.next is None:
            self.tail = node
```

##### remove方法实现

remove方法接收一个idx参数，表示要删除节点的索引，此方法要考虑以下几种情况：

1. 空链表，直接抛出异常
2. 删除第一个节点时，移动head到删除节点的next指针指向的对象
3. 链表只有一个节点时，把head与tail都指向None即可
4. 删除最后一个节点时，需要移动tail到上一个节点
5. 遍历链表时要判断给定的索引是否大于链表的长度，如果大于则抛出异常信息

请看下边图例：

[<img src="https://zhaochj.github.io/images/2016-05-13-10.jpg" alt="链表" style="zoom:67%;" />](https://zhaochj.github.io/images/2016-05-13-10.jpg)

[<img src="https://zhaochj.github.io/images/2016-05-13-11.jpg" alt="链表" style="zoom:67%;" />](https://zhaochj.github.io/images/2016-05-13-11.jpg)

以下为remove函数的代码：

```python
def remove(self, idx):
       cur = self.head
       cur_idx = 0
       if self.head is None:  # 空链表时
           raise Exception('The list is an empty list')
       while cur_idx < idx-1:
           cur = cur.next
           if cur is None:
               raise Exception('list length less than index')
           cur_idx += 1
       if idx == 0:   # 当删除第一个节点时
           self.head = cur.next
           cur = cur.next
           return
       if self.head is self.tail:   # 当只有一个节点的链表时
           self.head = None
           self.tail = None
           return
       cur.next = cur.next.next
       if cur.next is None:  # 当删除的节点是链表最后一个节点时
           self.tail = cur
```

##### size函数实现

size函数不接收参数，返回链表中节点的个数，要获得链表的节点个数，必定会遍历链表，直到最后一个节点的`next`指针指向`None`时链表遍历完成，遍历时可以用一个累加器来计算节点的个数，如下代码：

```python
def size(self):
        current = self.head
        count = 0
        if current is None:
            return 'The list is an empty list'
        while current is not None:
            count += 1
            current = current.next
        return count
```

##### search函数实现

search函数接收一个item参数，表示查找节点中数据域的值。search函数遍历链表，每到一个节点把当前节点的`data`值与`item`作比较，最糟糕的情况下会全遍历链表。如果查找到有些数据则返回`True`，否则返回`False`，代码如下：

```python
def search(self, item):
        current = self.head
        found = False
        while current is not None and not found:
            if current.data == item:
                found = True
            else:
                current = current.next
        return found
```



#### Reference

---

[^1]: https://zhaochj.github.io/2016/05/12/2016-05-12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/



---

### 1.1.3  栈Stack

栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

栈又被称为LIFO(后入先出)表。

```python
Stack()   # 建立一个空的栈对象
push()    # 把一个元素添加到栈的最顶层
pop()     # 删除栈最顶层的元素，并返回这个元素
peek()    # 返回最顶层的元素，并不删除它
isEmpty() # 判断栈是否为空
size()    # 返回栈中元素的个数
```

#### 栈的实现

```python
class Stack(object):
    def __init__(self):
        self.stack=[]
    def isEmpty(self):
        return self.stack==[]
    def push(self,item):
        self.stack.append(item)
    def pop(self):
        if self.isEmpty():
            raise IndexError,'pop from empty stack'
        return self.stack.pop()
    def peek(self):
        return self.stack[-1]
    def size(self):
        return len(self.stack)
```

####  栈应用

**检查程序中成对的符号**

程序的语法错误经常是由缺少一个符号造成的。可用栈来检查符号是否成对。做一个空栈，如果字符是开放符号('({[')则将其push栈中。如果符号是个闭合符号(')]}'),则当栈空时报错，对应'()}'的错误。否则，将栈pop，如果弹出的符号不是对应的开放符号，则报错，对应'(}'的错误。文件末尾，如果栈为空，则报错，对应'({}'的错误。 

```python
def match(i,j):
    opens='([{'
    closes=')]}'
    return opens.index(i)==closes.index(j)
def syntaxChecker(string):
    stack=Stack()
    balanced=True
    for i in string:
        if i in '([{':
            stack.push(i)
        elif i in ')]}':
            if stack.isEmpty():
                balanced=False
                break
            else:
                j=stack.pop()
                if not match(j,i):
                    balanced=False
                    break
    if not stack.isEmpty():
        balanced=False
    return balanced
```

**进制转换**

十进制转换二进制：把十进制转成二进制一直分解至商数为0。从最底左边数字开始读，之后读右边的数字，从下读到上。

<img src="https://images0.cnblogs.com/blog/601033/201402/201059591583022.png" alt="img" style="zoom:67%;" />

```python
def decimal_to_bin(dec):
    stack=Stack()
    cur=dec
    while cur>0:
        a=cur%2
        cur=cur/2
        stack.push(a)
    binstr=''
    while not stack.isEmpty():
        binstr+=str(stack.pop())
    return binstr
```

**后缀记法**

后缀记法(postfix)，使用一个栈，见到一个数时入栈，遇到一个运算符时就作用于从栈弹出的两个元素，将结果弹入栈中。

(7+8)/(3+2)可以写作7 8 + 3 2 + /

来自《Problem Solving with Algorithms and Data Structures》的图片：

<img src="https://images0.cnblogs.com/blog/601033/201402/201111392494571.png" alt="img" style="zoom:67%;" />

 中缀到后缀的转换：当读到一个操作数的时候，放到输出中。读到操作符(+,-,*,/)时，如果栈为空，则压入栈中，否则弹出栈元素放到输出中直到发现优先级更低的元素为止。读到'(',压入栈中，读到')',弹出栈元素并发到输出中直到发现'('为止。在末尾，将栈元素弹出直到该栈变成空栈。

来自《Problem Solving with Algorithms and Data Structures》的图片：

<img src="https://images0.cnblogs.com/blog/601033/201402/221113035229421.png" alt="img" style="zoom:67%;" />

```python
def infixtoPostfix(infix):
    a={}
    a['*']=3
    a['/']=3
    a['+']=2
    a['-']=2
    a['(']=1
    stack=Stack()
    post=''
    for i in infix:
        if i not in a and i!=')':
            post+=i
        elif i=='(':
            stack.push(i)
        elif i==')':
            top=stack.pop()
            while top!='(':
                post+=top
                top=stack.pop()
        else:         
            while not stack.isEmpty() and a[i]<=a[stack.peek()]:
                post+=stack.pop()
            stack.push(i)
    while not stack.isEmpty():
        post+=stack.pop()
    return post
                    
def postfixExp(postfix):
    stack=Stack()
    postlist=postfix.split()
    for i in postlist:
        if i not in '+-*/':
            stack.push(i)
        else:
            a=stack.pop()
            b=stack.pop()
            result=math(i,b,a)
            stack.push(result)
    return stack.pop()
def math(x,y,z):
    if x=='+':
        return float(y)+float(z)
    if x=='-':
        return float(y)-float(z)
    if x=='*':
        return float(y)*float(z)
    if x=='/':
        return float(y)/float(z)
```



---

### 1.1.4 队列(Queue)

队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

队列是一种特殊的线性表，它只允许在表的前端(front)进行删除操作，而在表的后端(rear)进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。

队列(queue)也是表，使用队列时插入和删除在不同的端进行。队列的基本操作是Enqueue(入队)，在表的末端(rear)插入一个元素，还有出列(Dequeue)，删除表开头的元素。

代码实现：

```python
class Queue(object):
    def __init__(self):
        self.queue=[]
    def isEmpty(self):
        return self.queue==[]
    def enqueue(self,x):
        self.queue.append(x)
    def dequeue(self):
        if self.queue:
            a=self.queue[0]
            self.queue.remove(a)
            return a
        else:
            raise IndexError,'queue is empty'
    def size(self):
        return len(self.queue)
```

#### 队列类型

* FIFO：       先进先出
* LIFO：       后进先出(相当于栈)
* 双端队列：LIFO和FIFO的结合，就是可从队首和队尾添加和删除元素。
* 循环队列：队首和队尾相连(可以解决假溢出)

##### 队列Queue(import queue)

队列类型：

* FIFO(queue.queue)、
* LIFO(queue.LifoQueue)、
* 优先级队列(queue.PriorityQueue)# 优先级队列越低越先出来(堆)

**FIFO：**
`q=queue.queue(maxsize=10)`     # 创建一个队列长度为10的对象
	q.put(x)                                         # 队尾插入数据x
	q.get()                                            # 队首删除数据并返回该数据
	q.qsize()                                        # 返回队列的大小
	q.empty()                                     # 判断队列是否为空：若为空则返回True，反之则FALSE
	q.full()                                           # 判断是否为满：与maxsize相呼应

##### 双端队列Deque(from collections import deque)

双端队列（deque，全名double-ended queue），是一种具有队列和栈的性质的数据结构。

双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队。

  `q=deque(5)`     # 新建一个一个大小为5的deque对象
	q.appendleft(x)：在列表左侧插入	                     O(1)
	q.popleft()：         弹出列表左侧的值                     O(1)
	extendleft：         在左侧扩展                                 O(k)
	q.append(x)：      在列表右侧插入                         O(1)
	q.pop()：               弹出列表右侧的值                     O(1)
	extend：               在右侧扩展                                 O(k)
	q.rotate(-n)：        将左端的n个元素移动到右端   O(k)
　q.rotate(n)：         将右端的n个元素移动到左端
　　q=deque('abcdef')
        q.rotate(-2)
        print(q)               # deque(['c','d','e','f','a','b'])
        q.rotate(2)
        print(q)               # deque(['e','f','a','b','c','d'])
	q.remove('c')：      删除一个指定元素                     O(n)
	q.clear()：              清空链表所有元素，使其长度为0
	q.reverse()：         将队列反转
	q.count(x)：           返回q中x的数量
	len(q)：                   返回q的长度

##### 循环队列LoopQueue

队尾出来进队首，双端队列的rotate可以实现循环队列。

```python
# 循环队列
class LoopQueue:

    def __init__(self, max_size):
        self._queue = [None] * max_size
        self._front = 0
        self._rear = 0
        self._max_size = max_size

    # 让队列支持遍历，支持for语句
    def __iter__(self):
        cursor = self._front
        while cursor != self._rear:
            yield self._queue[cursor]
            cursor = (cursor + 1) % self._max_size

    def is_empty(self):
        return self._front == self._rear

    def enqueue(self, data):
        if (self._rear + 1) % self._max_size == self._front:
            print("the queue is full")
        self._queue[self._rear] = data
        self._rear = (self._rear + 1) % self._max_size

    def dequeue(self):
        if self._front == self._rear:
            return "the current size of the queue is 0"
        rm_data = self._queue[self._front]
        self._queue[self._front] = None
        self._front = (self._front + 1) % self._max_size
        return rm_data

    def size(self):
        """返回当前队列的长度"""
        return (self._rear + self._max_size - self._front) % self._max_size
    
    # 取队首数据
    def get_front(self):
        if self._front == self._rear:
            return None
        return self._queue[self._front]
```

下面的例子是用queue中的FIFO实现一个功能，6个人传土豆，每数到7就淘汰手中有土豆的人，直到最后只剩一个人。

```python
#循环队列，num一定要比人数多
import queue
def hotpotato(namelist,num):
    que=queue.Queue(len(namelist))
    for name in namelist:
        que.put(name)
    while que.qsize()>1:
        for item in range(num):
            que.put(que.get())
        que.get()
    return que.get() namelist=['a','b','c','d','e','f']
print(hotpotato(namelist,7))
```

##### 优先队列PriorityQueue

优先队列和普通队列结构一样，数据从逻辑队尾进入队列，数据从逻辑队首移除。不同的是，从队首移除数据总会移除优先级最高的数据，而从队尾加入数据，也是根据某种顺序添加到队列中

1. 优先队列的数据结构是基于完全二叉树的特点：从任一叶子节点开始到根结点的一条路径是有序列表，如果是最大堆，则由叶子结点到根结点的路径上的所有结点数据呈现从小到大的变化，而最小堆则刚好相反。完全二叉堆（树）又是二叉树类型中的一种，所以要理解原理，需要理解树结构相关的知识
2. 二叉堆（不论是最小堆还是最大堆结构），一般都会提供如下几个接口，用来构建优先队列，二叉堆的数据插入，二叉堆的数据删除，二叉堆的根结点元素的值，以及将杂乱的序列（列表等数据结构）转化为堆结构。优先队列也是通过二叉堆内部的这几个接口达成目的

```python
import heapq

class PriorityQueue(object):
    def __init__(self):
        self._queue = []        #创建一个空列表用于存放队列
        self._index = 0        #保证同等优先级元素插入时的正确排序
    
    def push(self, item, priority):
        """队列每个数据项都由（priority, index, item)元组构成"""
        heapq.heappush(self._queue, (-priority, self._index, item)) 
        self._index += 1
        
    def pop(self):
        #  heappop() 函数总是返回”最小的”的元素
        return heapq.heappop(self._queue)[-1]    #返回拥有最高优先级的项

class Item(object):
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return 'Item: {!r}'.format(self.name)

if __name__ == '__main__':
    >>> q = PriorityQueue()
    >>> q.push(Item('foo'), 1)
    >>> q.push(Item('bar'), 5)
    >>> q.push(Item('spam'), 4)
    >>> q.push(Item('grok'), 1)
    >>> q.pop()
    Item('bar')
    >>> q.pop()
    Item('spam')
    >>> q.pop()
    Item('foo')
    >>> q.pop()
    Item('grok')
```

#### 应用

著名的 约瑟夫斯问题(Josephus Problem)是应用队列(确切地说，是循环队列)的典型案例。在 约瑟夫斯问题 中，参与者围成一个圆圈，从某个人(队首)开始报数，报数到n+1的人退出圆圈，然后从退出人的下一位重新开始报数；重复以上动作，直到只剩下一个人为止。

值得注意的是，Queue类只实现了简单队列，上述问题实际上需要用循环队列来解决。在报数过程中，通过“将(从队首)出队的人再入队(到队尾)”来模拟循环队列的行为。

代码实现：

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
def josephus(namelist, num):
  simqueue = Queue()
  for name in namelist:
    simqueue.enqueue(name)
  while simqueue.size() > 1:
    for i in xrange(num):
      simqueue.enqueue(simqueue.dequeue())
    simqueue.dequeue()
  return simqueue.dequeue()
if __name__ == '__main__':
  print(josephus(["Bill", "David", "Kent", "Jane", "Susan", "Brad"], 3))
```



---

### 1.1.5 堆Heap

#### import heapq

实现最小堆：

- heap = []                                          #创建了一个空堆
- heapq.**heappush** ( heap,item )   #往堆heap中插入一条新的值item
- heapq.**heapify**(listx)                      #以线性时间将一个列表转化成堆
- item = heapq.**heappop** ( heap )   # 从堆中弹出最小值
- item = heap [0]                                #查看堆中最小值，不弹出
- item = heapq.heapreplace(heap,item)   #弹出并返回最小值，然后将heapreplace方法中item的值插入到堆中，堆的整体结构不会发生改变。这里需要考虑到的情况就是如果弹出的值大于item的时候我们可能就需要添加条件来满足function的要求：
  - if item > heap[0]：  item = heapreplace(heap, item)
- heapq.**heappushpop**()                  #顾名思义，将值插入到堆中同时弹出堆中的最小值。
- merge(heap1,heap2,heap3)         #合并多个堆然后输出
- heapq.**nlargest**(n , heap, key=None)         #从堆中找出做大的N个数，key的作用和sorted( )方法里面的key类似，用列表元素的某个属性和函数作为关键字。
- heapq.**nsmallest**(n, iterable, key=None)   #找到堆中最小的N个数用法同上。

实现最大堆：将元素取反存入堆，取出时再取反：将push(e)改为push(-e)、pop(e)改为-pop(e)。

#### 堆(heap)

又被为优先队列(priority queue)。尽管名为优先队列，但堆并不是队列。回忆一下，在队列中，我们可以进行的限定操作是dequeue和enqueue。

dequeue是按照进入队列的先后顺序来取出元素。而在堆中，我们不是按照元素进入队列的先后顺序取出元素的，而是按照元素的优先级取出元素。

#### 性质

堆的实现通过构造**二叉堆**（binary heap），实为[二叉树](https://zh.wikipedia.org/wiki/二叉树)的一种；由于其应用的普遍性，当不加限定时，均指该数据结构的这种实现。这种数据结构具有以下性质。

- 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（**堆序性**）。
- 堆总是一棵[完全树](https://zh.wikipedia.org/wiki/完全二叉树)。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。

#### 实现

- 堆的主要操作是插入和删除最小元素(元素值本身为优先级键值，小元素享有高优先级)
- 在插入或者删除操作之后，我们必须保持该实现应有的性质: 1. 完全二叉树 2. 每个节点值都小于或等于它的子节点

**上浮（Promotion）**

情境: 子节点的键值变为比父节点的键值大；如下面添加字节点

消除这种违反项：

- 交换子节点的键和父节点的键
- 重复这个过程直到堆的顺序恢复正常

**堆的添加：**

<img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTguY25ibG9ncy5jb20vYmxvZy8xMzg3MzM4LzIwMTgwNi8xMzg3MzM4LTIwMTgwNjE5MjIxOTQ1Njk1LTQyNjU0NzQ2OC5wbmc=.jpg" alt="img" style="zoom:67%;" />

```python
def _upheap(self, j):#往上交换
        parent = self._parent(j)
        if j > 0 and self._data[j] < self._data[parent]:
            self._swap(j, parent)
            self._upheap(parent) 
```

下沉（Demotion）

情境：父节点的键值变得比子节点（一个或者2个） 的键值还小 ，如下面删除了根节点后拿了个小子节点补充上来的情况

消除这种违反项：

- 把父节点的键值和比它大的子节点的键值做交换
- 重复这个操作直到堆的顺序恢复正常

**删除最大值**

<img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTguY25ibG9ncy5jb20vYmxvZy8xMzg3MzM4LzIwMTgwNi8xMzg3MzM4LTIwMTgwNjE5MjIyNDM1MDE4LTEzNDExNjExMS5wbmc=.jpg" alt="img" style="zoom:67%;" />

```python
def _downheap(self, j):#往下交换，递归比较三个值
        if self._has_left(j):
            left = self._left(j)
            small_child = left
            if self._has_right(j):
                right = self._right(j)
                if self._data[right] < self._data[left]:
                    small_child = right
            if self._data[small_child] < self._data[j]:
                self._swap(j, small_child)
                self._downheap(small_child)
```

#### 复杂度分析

![img](https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTguY25ibG9ncy5jb20vYmxvZy8xMzg3MzM4LzIwMTgwNi8xMzg3MzM4LTIwMTgwNjE5MjIyNjA4MjYyLTE1NTg3MzQ5MDQucG5n.jpg)

构建堆的代码：

```python
#该heap为min_heap，即根节点为最小值
class PriorityQueueBase:
    #抽象基类为堆
 
    class Item:
        #轻量级组合来存储堆项目
        __slots__ = '_key' , '_value'
 
        def __init__ (self, k, v):
            self._key = k
            self._value = v
 
        def __lt__ (self, other):     #比较大小
            return self._key < other._key
 
        def is_empty(self):
            return len(self) == 0   
 
        def __str__(self):
            return str(self._key)
 
class HeapPriorityQueue(PriorityQueueBase):
 
    def __init__ (self):
        self._data = [ ]         
 
    def __len__ (self):
        return len(self._data)
 
    def is_empty(self):
        return len(self) == 0  
 
    def add(self, key, value):   #在后面加上然后加上
        self._data.append(self.Item(key, value))
        self._upheap(len(self._data) - 1)
 
    def min(self):
        if self.is_empty():
            raise ValueError( "Priority queue is empty." )
        item = self._data[0]
        return (item._key, item._value)
 
    def remove_min(self):
        if self.is_empty():
            raise ValueError( "Priority queue is empty." )
        self._swap(0, len(self._data) - 1)
        item = self._data.pop( )
        self._downheap(0)
        return (item._key, item._value)
 
    def _parent(self, j):
        return (j - 1) // 2
 
    def _left(self, j):
        return 2 * j + 1
 
    def _right(self, j):
        return 2 * j + 2
 
    def _has_left(self, j):
        return self._left(j) < len(self._data)
 
    def _has_right(self, j):
        return self._right(j) < len(self._data)      
 
    def _swap(self, i, j):
        self._data[i], self._data[j] = self._data[j], self._data[i]
 
    def _upheap(self, j):#往上交换
        parent = self._parent(j)
        if j > 0 and self._data[j] < self._data[parent]:
            self._swap(j, parent)
            self._upheap(parent) 
 
    def _downheap(self, j):#往下交换，递归比较三个值
        if self._has_left(j):
            left = self._left(j)
            small_child = left
            if self._has_right(j):
                right = self._right(j)
                if self._data[right] < self._data[left]:
                    small_child = right
            if self._data[small_child] < self._data[j]:
                self._swap(j, small_child)
                self._downheap(small_child)  
 
heap = HeapPriorityQueue()
heap.add(4, "D")
heap.add(3, "C")
heap.add(1, "A")
heap.add(5, "E")
heap.add(2, "B")
heap.add(7, "G")
heap.add(6, "F")
heap.add(26, "Z")
 
for item in heap._data:
    print(item)
 
print("min is: ")
print(heap.min())
print()
 
print("remove min: ")
print(heap.remove_min())
print("Now min is: ")
print(heap.min())
print()
 
print("remove min: ")
print(heap.remove_min())
print("Now min is: ")
print(heap.min())
print()
 
heap.add(1, "A")
print("Now min is: ")
print(heap.min())
print()
 
#输出结果
1
2
3
5
4
7
6
26
min is:
(1, 'A')
 
remove min:
(1, 'A')
Now min is:
(2, 'B')
 
remove min:
(2, 'B')
Now min is:
(3, 'C')
 
Now min is:
(1, 'A')
```

**python内置方法创建堆有两种方式，heappush()和heapify()**：

```python
'''
heaqp模块提供了堆队列算法的实现，也称为优先级队列算法。
要创建堆，请使用初始化为[]的列表，或者可以通过函数heapify（）将填充列表转换为堆。
提供以下功能：
heapq.heappush（堆，项目）
将值项推入堆中，保持堆不变。
heapq.heapify（x）
在线性时间内将列表x转换为堆。
heapq.heappop（堆）
弹出并返回堆中的最小项，保持堆不变。如果堆是空的，则引发IndexError。
'''
import heapq  #1 heappush生成堆+ heappop把堆从小到大pop出来
heap = []
data = [1,3,5,7,9,2,4,6,8,0]
for i in data:
    heapq.heappush(heap,i)
print(heap) lis = []
while heap:
    lis.append(heapq.heappop(heap))
print(lis) #2 heapify生成堆+ heappop把堆从小到大pop出来
data2 = [1,5,3,2,9,5]
heapq.heapify(data2)
print(data2) lis2 = []
while data2:
    lis2.append(heapq.heappop(data2))
print(lis2) #输出结果
[0, 1, 2, 6, 3, 5, 4, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 5, 9, 5]
[1, 2, 3, 5, 5, 9]
```



---

### 1.1.6 哈希

#### 散列表（Hash Table）

散列表：所有的元素之间没有任何关系。元素的存储位置，是利用元素的关键字通过某个函数直接计算出来的。这个一一对应的关系函数称为散列函数或Hash函数。
采用散列技术将记录存储在一块连续的存储空间中，称为散列表或哈希表（Hash Table）。关键字对应的存储位置，称为散列地址。

散列表是一种面向查找的存储结构。它最适合求解的问题是查找与给定值相等的记录。但是对于某个关键字能对应很多记录的情况就不适用，比如查找所有的“男”性。也不适合范围查找，比如查找年龄20~30之间的人。排序、最大、最小等也不合适。

因此，散列表通常用于关键字不重复的数据结构。比如python的字典数据类型。

设计出一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。
但是，一般散列函数都面临着冲突的问题。
冲突：两个不同的关键字，通过散列函数计算后结果却相同的现象。collision。

##### 散列函数的构造方法

好的散列函数：计算简单、散列地址分布均匀

1. 直接定址法
   例如取关键字的某个线性函数为散列函数：
   f(key) = a*key + b (a,b为常数）
2. 数字分析法
   抽取关键字里的数字，根据数字的特点进行地址分配
3. 平方取中法
   将关键字的数字求平方，再截取部分
4. 折叠法
   将关键字的数字分割后分别计算，再合并计算，一种玩弄数字的手段。
5. 除留余数法
   最为常见的方法之一。
   对于表长为m的数据集合，散列公式为：
   f(key) = key mod p (p<=m)
   mod：取模（求余数）
   该方法最关键的是p的选择，而且数据量较大的时候，冲突是必然的。一般会选择接近m的质数。
6. 随机数法
   选择一个随机数，取关键字的随机函数值为它的散列地址。
   f(key) = random(key)

总之，实际情况下根据不同的数据特性采用不同的散列方法，考虑下面一些主要问题：

- 计算散列地址所需的时间
- 关键字的长度
- 散列表的大小
- 关键字的分布情况
- 记录查找的频率

##### 处理散列冲突

- 开放定址法

就是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。

公式是：

![img](http://www.uml.org.cn/python/images/20171218332.png)

这种简单的冲突解决办法被称为线性探测，无非就是自家的坑被占了，就逐个拜访后面的坑，有空的就进，也不管这个坑是不是后面有人预定了的。

线性探测带来的最大问题就是冲突的堆积，你把别人预定的坑占了，别人也就要像你一样去找坑。

改进的办法有二次方探测法和随机数探测法。

- 再散列函数法
  发生冲突时就换一个散列函数计算，总会有一个可以把冲突解决掉，它能够使得关键字不产生聚集，但相应地增加了计算的时间。
- 链接地址法
  碰到冲突时，不更换地址，而是将所有关键字为同义词的记录存储在一个链表里，在散列表中只存储同义词子表的头指针，如下图：

![img](http://www.uml.org.cn/python/images/20171218333.png)

这样的好处是，不怕冲突多；缺点是降低了散列结构的随机存储性能。本质是用单链表结构辅助散列结构的不足。

- 公共溢出区法
  其实就是为所有的冲突，额外开辟一块存储空间。如果相对基本表而言，冲突的数据很少的时候，使用这种方法比较合适。

![img](http://www.uml.org.cn/python/images/20171218334.png)

##### 散列表查找实现

下面是一段简单的实现代码：

```python
# 忽略了对数据类型，元素溢出等问题的判断。
 
class HashTable:
  def __init__(self, size):
    self.elem = [None for i in range(size)] # 使用list数据结构作为哈希表元素保存方法
    self.count = size # 最大表长
 
  def hash(self, key):
    return key % self.count # 散列函数采用除留余数法
 
  def insert_hash(self, key):
    """插入关键字到哈希表内"""
    address = self.hash(key) # 求散列地址
    while self.elem[address]: # 当前位置已经有数据了，发生冲突。
      address = (address+1) % self.count # 线性探测下一地址是否可用
    self.elem[address] = key # 没有冲突则直接保存。
 
  def search_hash(self, key):
    """查找关键字，返回布尔值"""
    star = address = self.hash(key)
    while self.elem[address] != key:
      address = (address + 1) % self.count
      if not self.elem[address] or address == star: # 说明没找到或者循环到了开始的位置
        return False
    return True
 
 
if __name__ == '__main__':
  list_a = [12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34]
  hash_table = HashTable(12)
  for i in list_a:
    hash_table.insert_hash(i)
 
  for i in hash_table.elem:
    if i:
      print((i, hash_table.elem.index(i)), end=" ")
  print("\n")
 
  print(hash_table.search_hash(15))
  print(hash_table.search_hash(33))
```

##### 散列表查找性能分析

如果没发生冲突，则其查找时间复杂度为O(1)，属于最极端的好了。

但是，现实中冲突可不可避免的，下面三个方面对查找性能影响较大：

- 散列函数是否均匀
- 处理冲突的办法
- 散列表的装填因子（表内数据装满的程度）



---

### 1.1.8 树

#### 二叉排序树

二叉排序树又称为二叉查找树。它或者是一颗空树，或者是具有下列性质的二叉树：

- 若它的左子树不为空，则左子树上所有节点的值均小于它的根结构的值；
- 若它的右子树不为空，则右子树上所有节点的值均大于它的根结构的值；
- 它的左、右子树也分别为二叉排序树。

![img](http://www.uml.org.cn/python/images/2017121833.png)

构造一颗二叉排序树的目的，往往不是为了排序，而是为了提高查找和插入删除关键字的速度。

二叉排序树的操作：

1. 查找：对比节点的值和关键字，相等则表明找到了；小了则往节点的左子树去找，大了则往右子树去找，这么递归下去，最后返回布尔值或找到的节点。
2. 插入：从根节点开始逐个与关键字进行对比，小了去左边，大了去右边，碰到子树为空的情况就将新的节点链接。
3. 删除：如果要删除的节点是叶子，直接删；如果只有左子树或只有右子树，则删除节点后，将子树链接到父节点即可；如果同时有左右子树，则可以将二叉排序树进行中序遍历，取将要被删除的节点的前驱或者后继节点替代这个被删除的节点的位置。

二叉排序树总结：

- 二叉排序树以链式进行存储，保持了链接结构在插入和删除操作上的优点。
- 在极端情况下，查询次数为1，但最大操作次数不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉排序树的形状，也就引申出了后面的平衡二叉树。
- 给定一个元素集合，可以构造不同的二叉排序树，当它同时是一个完全二叉树的时候，查找的时间复杂度为O(log(n))，近似于二分查找。
- 当出现最极端的斜树时，其时间复杂度为O(n)，等同于顺序查找，效果最差。

![img](http://www.uml.org.cn/python/images/2017121834.png)

#### 平衡二叉树（AVL树)

平衡二叉树（AVL树，发明者的姓名缩写）：一种高度平衡的排序二叉树，其每一个节点的左子树和右子树的高度差最多等于1。

平衡二叉树首先必须是一棵二叉排序树！

平衡因子（Balance Factor）：将二叉树上节点的左子树深度减去右子树深度的值。

对于平衡二叉树所有包括分支节点和叶节点的平衡因子只可能是-1,0和1，只要有一个节点的因子不在这三个值之内，该二叉树就是不平衡的。

<img src="http://www.uml.org.cn/python/images/2017121835.png" alt="img" style="zoom: 33%;" />

最小不平衡子树：距离插入结点最近的，且平衡因子的**绝对值**大于1的节点为根的子树。

**平衡二叉树的构建思想**：
每当插入一个新结点时，先检查是否破坏了树的平衡性，若有，找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的连接关系，进行相应的旋转，成为新的平衡子树。

下面是由[1,2,3,4,5,6,7,10,9]构建平衡二叉树

<img src="http://www.uml.org.cn/python/images/2017121836.png" alt="img" style="zoom:33%;" />

<img src="http://www.uml.org.cn/python/images/2017121837.png" alt="img" style="zoom:33%;" />

<img src="http://www.uml.org.cn/python/images/2017121838.png" alt="img" style="zoom:33%;" />

<img src="http://www.uml.org.cn/python/images/2017121839.png" alt="img" style="zoom:33%;" />

<img src="http://www.uml.org.cn/python/images/20171218310.png" alt="img" style="zoom:33%;" />

<img src="http://www.uml.org.cn/python/images/20171218311.png" alt="img" style="zoom:33%;" />

<img src="http://www.uml.org.cn/python/images/20171218312.png" alt="img" style="zoom:33%;" />

#### 多路查找树（B树）

多路查找树（muitl-way search tree）：其每一个节点的孩子可以多于两个，且每一个结点处可以存储多个元素。

对于多路查找树，每个节点可以存储多少个元素，以及它的孩子数的多少是关键，常用的有这4种形式：2-3树、2-3-4树、B树和B+树。

##### 2-3树

2-3树：每个结点都具有2个孩子，或者3个孩子，或者没有孩子。

一个2结点包含一个元素和两个孩子（或者没有孩子，不能只有一个孩子）。与二叉排序树类似，其左子树包含的元素都小于该元素，右子树包含的元素都大于该元素。

一个3结点包含两个元素和三个孩子（或者没有孩子，不能只有一个或两个孩子）。

2-3树中所有的叶子都必须在同一层次上。

<img src="http://www.uml.org.cn/python/images/20171218313.png" alt="img" style="zoom: 50%;" />

其插入操作如下：

<img src="http://www.uml.org.cn/python/images/20171218314.png" alt="img" style="zoom: 50%;" />

<img src="http://www.uml.org.cn/python/images/20171218315.png" alt="img" style="zoom: 50%;" />

<img src="http://www.uml.org.cn/python/images/20171218316.png" alt="img" style="zoom: 50%;" />

<img src="http://www.uml.org.cn/python/images/20171218317.png" alt="img" style="zoom: 50%;" />

其删除操作如下：

<img src="http://www.uml.org.cn/python/images/20171218318.png" alt="img" style="zoom: 50%;" />

<img src="http://www.uml.org.cn/python/images/20171218319.png" alt="img" style="zoom: 50%;" />

<img src="http://www.uml.org.cn/python/images/20171218320.png" alt="img" style="zoom: 50%;" />

<img src="http://www.uml.org.cn/python/images/20171218321.png" alt="img" style="zoom: 50%;" />

<img src="http://www.uml.org.cn/python/images/20171218322.png" alt="img" style="zoom: 50%;" />

<img src="http://www.uml.org.cn/python/images/20171218323.png" alt="img" style="zoom: 50%;" />

<img src="http://www.uml.org.cn/python/images/20171218324.png" alt="img" style="zoom: 50%;" />

<img src="http://www.uml.org.cn/python/images/20171218325.png" alt="img" style="zoom: 50%;" />

##### 2-3-4树

其实就是2-3树的扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子）。

其插入操作:

![img](http://www.uml.org.cn/python/images/20171218326.png)

其删除操作：

![img](http://www.uml.org.cn/python/images/20171218327.png)

##### B树

B树是一种平衡的多路查找树。节点最大的孩子数目称为B树的阶（order）。2-3树是3阶B树，2-3-4是4阶B树。

B树的数据结构主要用在内存和外部存储器的数据交互中。

![img](http://www.uml.org.cn/python/images/20171218328.png)

![img](http://www.uml.org.cn/python/images/20171218329.png)

![img](http://www.uml.org.cn/python/images/20171218330.png)

##### B+树

为了解决B树的所有元素遍历等基本问题，在原有的结构基础上，加入新的元素组织方式后，形成了B+树。

B+树是应文件系统所需而出现的一种B树的变形树，严格意义上将，它已经不是最基本的树了。

B+树中，出现在分支节点中的元素会被当做他们在该分支节点位置的中序后继者（叶子节点）中再次列出。另外，每一个叶子节点都会保存一个指向后一叶子节点的指针。

![img](http://www.uml.org.cn/python/images/20171218331.png)

所有的叶子节点包含全部的关键字的信息，及相关指针，叶子节点本身依关键字的大小自小到大顺序链接

B+树的结构特别适合带有范围的查找。比如查找年龄在20~30岁之间的人。

#### 树表查找

##### 1. 二叉树查找

###### 算法简介 

二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 

###### 算法思想 

二叉查找树（BinarySearch Tree）或者是一棵空树，或者是具有下列性质的二叉树：
	1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
	2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
	3）任意节点的左、右子树也分别为二叉查找树。 二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。

![图片](https://mmbiz.qpic.cn/mmbiz_png/viaxzHeHib8eibFvME0ic7AEWvZEOib58ddicuIj4HWHt8wGibBgjx8LTJ5UGeNjm1oEk513wyVNW2CSyCrZ9fPjXj6wA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

###### 复杂度分析 

它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。

###### 算法实现

```python
# 二叉树查找 Python实现
class BSTNode:
    """
    定义一个二叉树节点类。
    以讨论算法为主，忽略了一些诸如对数据类型进行判断的问题。
    """
    def __init__(self, data, left=None, right=None):
        """
        初始化
        :param data: 节点储存的数据
        :param left: 节点左子树
        :param right: 节点右子树
        """
        self.data = data
        self.left = left
        self.right = right


class BinarySortTree:
    """
    基于BSTNode类的二叉查找树。维护一个根节点的指针。
    """
    def __init__(self):
        self._root = None

    def is_empty(self):
        return self._root is None

    def search(self, key):
        """
        关键码检索
        :param key: 关键码
        :return: 查询节点或None
        """
        bt = self._root
        while bt:
            entry = bt.data
            if key < entry:
                bt = bt.left
            elif key > entry:
                bt = bt.right
            else:
                return entry
        return None

    def insert(self, key):
        """
        插入操作
        :param key:关键码 
        :return: 布尔值
        """
        bt = self._root
        if not bt:
            self._root = BSTNode(key)
            return
        while True:
            entry = bt.data
            if key < entry:
                if bt.left is None:
                    bt.left = BSTNode(key)
                    return
                bt = bt.left
            elif key > entry:
                if bt.right is None:
                    bt.right = BSTNode(key)
                    return
                bt = bt.right
            else:
                bt.data = key
                return

    def delete(self, key):
        """
        二叉查找树最复杂的方法
        :param key: 关键码
        :return: 布尔值
        """
        p, q = None, self._root     # 维持p为q的父节点，用于后面的链接操作
        if not q:
            print("空树！")
            return
        while q and q.data != key:
            p = q
            if key < q.data:
                q = q.left
            else:
                q = q.right
            if not q:               # 当树中没有关键码key时，结束退出。
                return
        # 上面已将找到了要删除的节点，用q引用。而p则是q的父节点或者None（q为根节点时）。
        if not q.left:
            if p is None:
                self._root = q.right
            elif q is p.left:
                p.left = q.right
            else:
                p.right = q.right
            return
        # 查找节点q的左子树的最右节点，将q的右子树链接为该节点的右子树
        # 该方法可能会增大树的深度，效率并不算高。可以设计其它的方法。
        r = q.left
        while r.right:
            r = r.right
        r.right = q.right
        if p is None:
            self._root = q.left
        elif p.left is q:
            p.left = q.left
        else:
            p.right = q.left

    def __iter__(self):
        """
        实现二叉树的中序遍历算法,
        展示我们创建的二叉查找树.
        直接使用python内置的列表作为一个栈。
        :return: data
        """
        stack = []
        node = self._root
        while node or stack:
            while node:
                stack.append(node)
                node = node.left
            node = stack.pop()
            yield node.data
            node = node.right


if __name__ == '__main__':
    lis = [62, 58, 88, 48, 73, 99, 35, 51, 93, 29, 37, 49, 56, 36, 50]
    bs_tree = BinarySortTree()
    for i in range(len(lis)):
        bs_tree.insert(lis[i])
    # bs_tree.insert(100)
    bs_tree.delete(58)
    for i in bs_tree:
        print(i, end=" ")
    # print("\n", bs_tree.search(4))
```

##### 2. 平衡查找树之2-3查找树（2-3 Tree）    

###### 算法描述

####### 2-3查找树定义      

​		和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：
​	1）要么为空，要么：
​	2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。
​	3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。

####### 2-3查找树的性质 

​	1）如果中序遍历2-3查找树，就可以得到排好序的序列；
​	2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。） 

###### 复杂度分析

​		2-3树的查找效率与树的高度是息息相关的。
​		距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。
​		对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。

![图片](https://mmbiz.qpic.cn/mmbiz_png/viaxzHeHib8eibFvME0ic7AEWvZEOib58ddicu4pTpYLSIkc8Eeqjwq22jTQSbTLfWFpKc8VIpLKNz6lg5E8F4rrgO2g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

###### 算法实现

```python
class Node(object):
    def __init__(self,key):
        self.key1=key
        self.key2=None
        self.left=None
        self.middle=None
        self.right=None
    def isLeaf(self):
        return self.left is None and self.middle is None and self.right is None
    def isFull(self):
        return self.key2 is not None
    def hasKey(self,key):
        if (self.key1==key) or (self.key2 is not None and self.key2==key):
            return True
        else:
            return False
    def getChild(self,key):
        if key<self.key1:
            return self.left
        elif self.key2 is None:
            return self.middle
        elif key<self.key2:
            return self.middle
        else:
            return self.right
class 2_3_Tree(object):
    def __init__(self):
        self.root=None
    def get(self,key):
        if self.root is None:
            return None
        else:
            return self._get(self.root,key)
    def _get(self,node,key):
        if node is None:
            return None
        elif node.hasKey(key):
            return node
        else:
            child=node.getChild(key)
            return self._get(child,key)
    def put(self,key):
        if self.root is None:
            self.root=Node(key)
        else:
            pKey,pRef=self._put(self.root,key)
            if pKey is not None:
                newnode=Node(pKey)
                newnode.left=self.root
                newnode.middle=pRef
                self.root=newnode
    def _put(self,node,key):
        if node.hasKey(key):
            return None,None
        elif node.isLeaf():
            return self._addtoNode(node,key,None)
        else:
            child=node.getChild(key)
            pKey,pRef=self._put(child,key)
            if pKey is None:
                return None,None
            else:
                return self._addtoNode(node,pKey,pRef)
             
         
    def _addtoNode(self,node,key,pRef):
        if node.isFull():
            return self._splitNode(node,key,pRef)
        else:
            if key<node.key1:
                node.key2=node.key1
                node.key1=key
                if pRef is not None:
                    node.right=node.middle
                    node.middle=pRef
            else:
                node.key2=key
                if pRef is not None:
                    node.right=Pref
            return None,None
    def _splitNode(self,node,key,pRef):
        newnode=Node(None)
        if key<node.key1:
            pKey=node.key1
            node.key1=key
            newnode.key1=node.key2
            if pRef is not None:
                newnode.left=node.middle
                newnode.middle=node.right
                node.middle=pRef
        elif key<node.key2:
            pKey=key
            newnode.key1=node.key2
            if pRef is not None:
                newnode.left=Pref
                newnode.middle=node.right
        else:
            pKey=node.key2
            newnode.key1=key
            if pRef is not None:
                newnode.left=node.right
                newnode.middle=pRef
        node.key2=None
        return pKey,newnode
```

##### 3. 平衡查找树之红黑树（Red-Black Tree）

###### 红黑树的定义 

红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：
	① 红色节点向左倾斜 ；
	②一个节点不可能有两个红色链接；
	③整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。   

####### 红黑树的性质

​		整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。

![图片](https://mmbiz.qpic.cn/mmbiz_png/viaxzHeHib8eibFvME0ic7AEWvZEOib58ddicue2PIdGaOwBerfYTStzhp3N58YOMcCqbB99E6FXicXxYO4Q3iaDLrgquQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

###### 复杂度分析      

​		最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。
​		下图是一个典型的红黑树，从中可以看到最长的路径(红黑相间的路径)是最短路径的2倍：

![图片](https://mmbiz.qpic.cn/mmbiz_png/viaxzHeHib8eibFvME0ic7AEWvZEOib58ddicupuQrBVL0PvS7AKvUHsBDTSqmqWBWy16K0EibhdibWldNSWsRC4v8Uj6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

###### 算法实现

```python
#红黑树
from random import randint

RED = 'red'
BLACK = 'black'

class RBT:
    def __init__(self):
       # self.items = []
        self.root = None
        self.zlist = []

    def LEFT_ROTATE(self, x):
        # x是一个RBTnode
        y = x.right
        if y is None:
            # 右节点为空，不旋转
            return
        else:
            beta = y.left
            x.right = beta
            if beta is not None:
                beta.parent = x

            p = x.parent
            y.parent = p
            if p is None:
                # x原来是root
                self.root = y
            elif x == p.left:
                p.left = y
            else:
                p.right = y
            y.left = x
            x.parent = y

    def RIGHT_ROTATE(self, y):
        # y是一个节点
        x = y.left
        if x is None:
            # 右节点为空，不旋转
            return
        else:
            beta = x.right
            y.left = beta
            if beta is not None:
                beta.parent = y

            p = y.parent
            x.parent = p
            if p is None:
                # y原来是root
                self.root = x
            elif y == p.left:
                p.left = x
            else:
                p.right = x
            x.right = y
            y.parent = x

    def INSERT(self, val):

        z = RBTnode(val)
        y = None
        x = self.root
        while x is not None:
            y = x
            if z.val < x.val:
                x = x.left
            else:
                x = x.right

        z.PAINT(RED)
        z.parent = y

        if y is None:
            # 插入z之前为空的RBT
            self.root = z
            self.INSERT_FIXUP(z)
            return

        if z.val < y.val:
            y.left = z
        else:
            y.right = z

        if y.color == RED:
            # z的父节点y为红色，需要fixup。
            # 如果z的父节点y为黑色，则不用调整
            self.INSERT_FIXUP(z)

        else:
            return

    def INSERT_FIXUP(self, z):
        # case 1:z为root节点
        if z.parent is None:
            z.PAINT(BLACK)
            self.root = z
            return

        # case 2:z的父节点为黑色
        if z.parent.color == BLACK:
            # 包括了z处于第二层的情况
            # 这里感觉不必要啊。。似乎z.parent为黑色则不会进入fixup阶段
            return

        # 下面的几种情况，都是z.parent.color == RED:
        # 节点y为z的uncle
        p = z.parent
        g = p.parent  # g为x的grandpa
        if g is None:
            return
            #   return 这里不能return的。。。
        if g.right == p:
            y = g.left
        else:
            y = g.right

        # case 3-0:z没有叔叔。即：y为NIL节点
        # 注意，此时z的父节点一定是RED
        if y == None:
            if z == p.right and p == p.parent.left:
                # 3-0-0:z为右儿子,且p为左儿子，则把p左旋
                # 转化为3-0-1或3-0-2的情况
                self.LEFT_ROTATE(p)
                p, z = z, p
                g = p.parent
            elif z == p.left and p == p.parent.right:
                self.RIGHT_ROTATE(p)
                p, z = z, p

            g.PAINT(RED)
            p.PAINT(BLACK)
            if p == g.left:
                # 3-0-1:p为g的左儿子
                self.RIGHT_ROTATE(g)
            else:
                # 3-0-2:p为g的右儿子
                self.LEFT_ROTATE(g)

            return

        # case 3-1:z有黑叔
        elif y.color == BLACK:
            if p.right == z and p.parent.left == p:
                # 3-1-0:z为右儿子,且p为左儿子,则左旋p
                # 转化为3-1-1或3-1-2
                self.LEFT_ROTATE(p)
                p, z = z, p
            elif p.left == z and p.parent.right == p:
                self.RIGHT_ROTATE(p)
                p, z = z, p

            p = z.parent
            g = p.parent

            p.PAINT(BLACK)
            g.PAINT(RED)
            if p == g.left:
                # 3-1-1:p为g的左儿子，则右旋g
                self.RIGHT_ROTATE(g)
            else:
                # 3-1-2:p为g的右儿子，则左旋g
                self.LEFT_ROTATE(g)

            return


        # case 3-2:z有红叔
        # 则涂黑父和叔，涂红爷，g作为新的z，递归调用
        else:
            y.PAINT(BLACK)
            p.PAINT(BLACK)
            g.PAINT(RED)
            new_z = g
            self.INSERT_FIXUP(new_z)

    def DELETE(self, val):
        curNode = self.root
        while curNode is not None:
            if val < curNode.val:
                curNode = curNode.left
            elif val > curNode.val:
                curNode = curNode.right
            else:
                # 找到了值为val的元素,正式开始删除

                if curNode.left is None and curNode.right is None:
                    # case1:curNode为叶子节点：直接删除即可
                    if curNode == self.root:
                        self.root = None
                    else:
                        p = curNode.parent
                        if curNode == p.left:
                            p.left = None
                        else:
                            p.right = None

                elif curNode.left is not None and curNode.right is not None:
                    sucNode = self.SUCCESOR(curNode)
                    curNode.val, sucNode.val  = sucNode.val, curNode.val
                    self.DELETE(sucNode.val)

                else:
                    p = curNode.parent
                    if curNode.left is None:
                        x = curNode.right
                    else:
                        x = curNode.left
                    if curNode == p.left:
                        p.left = x
                    else:
                        p.right = x
                    x.parent = p
                    if curNode.color == BLACK:
                        self.DELETE_FIXUP(x)

                curNode = None
        return False

    def DELETE_FIXUP(self, x):
        p = x.parent
        # w:x的兄弟结点
        if x == p.left:
            w = x.right
        else:
            w = x.left

        # case1:x的兄弟w是红色的
        if w.color == RED:
            p.PAINT(RED)
            w.PAINT(BLACK)
            if w == p.right:
                self.LEFT_ROTATE(p)
            else:
                self.RIGHT_ROTATE(p)

        if w.color == BLACK:
            # case2:x的兄弟w是黑色的，而且w的两个孩子都是黑色的
            if w.left.color == BLACK and w.right.color == BLACK:
                w.PAINT(RED)
                if p.color == BLACK:
                    return
                else:
                    p.color = BLACK
                    self.DELETE_FIXUP(p)

            # case3:x的兄弟w是黑色的，而且w的左儿子是红色的，右儿子是黑色的
            if w.left.color == RED and w.color == BLACK:
                w.left.PAINT(BLACK)
                w.PAINT(RED)
                self.RIGHT_ROTATE(w)

            # case4:x的兄弟w是黑色的，而且w的右儿子是红
            if w.right.color == RED:
                p.PAINT(BLACK)
                w.PAINT(RED)
                if w == p.right:
                    self.LEFT_ROTATE(p)
                else:
                    self.RIGHT_ROTATE(p)

    def SHOW(self):
        self.DISPLAY1(self.root)
        return self.zlist

    def DISPLAY1(self, node):
        if node is None:
            return
        self.DISPLAY1(node.left)
        self.zlist.append(node.val)
        self.DISPLAY1(node.right)

    def DISPLAY2(self, node):
        if node is None:
            return
        self.DISPLAY2(node.left)
        print(node.val)
        self.DISPLAY2(node.right)

    def DISPLAY3(self, node):
        if node is None:
            return
        self.DISPLAY3(node.left)
        self.DISPLAY3(node.right)
        print(node.val)

class RBTnode:
    '''红黑树的节点类型'''
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.parent = None

    def PAINT(self, color):
        self.color = color

def zuoxuan(b, c):
    a = b.parent
    a.left = c
    c.parent = a
    b.parent = c
    c.left = b

if __name__ == '__main__':
    rbt=RBT()
    b = []

    for i in range(100):
        m = randint(0, 500)
        rbt.INSERT(m)
        b.append(m)

    a = rbt.SHOW()
    b.sort()
    equal = True
    for i in range(100):
        if a[i] != b[i]:
            equal = False
            break

    if not equal:
        print('wrong')
    else:
        print('OK!')
```

##### 4. B树和B+树（B Tree/B+ Tree）    

###### B树算法简介     

B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。
	①根节点至少有两个子节点；
	②每个节点有M-1个key，并且以升序排列；
	③位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间；
	④非叶子结点的关键字个数=指向儿子的指针个数-1；
	⑤非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] ；
	⑥其它节点至少有M/2个子节点；
	⑦所有叶子结点位于同一层；     如：（M=3）

![图片](https://mmbiz.qpic.cn/mmbiz_png/viaxzHeHib8eibFvME0ic7AEWvZEOib58ddiculUicnQB751oohek7KdAHweV2JMia5ibIvyEmJ7ibgNm48bickicDYrrrtyJA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

###### B树算法思想     

B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；    

B树的特性

​	1.关键字集合分布在整颗树中；
​	2.任何一个关键字出现且只出现在一个结点中；
​	3.搜索有可能在非叶子结点结束；
​	4.其搜索性能等价于在关键字全集内做一次二分查找；
​	5.自动层次控制；     

​	由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为O(LogN)

###### B+ 树算法简介

​    B+树是B-树的变体，也是一种多路搜索树：
​	1.其定义基本与B-树同，除了：
​	2.非叶子结点的子树指针与关键字个数相同；
​	3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树 
​	4.B-树是开区间；
​	5.为所有叶子结点增加一个链指针；
​	6.所有关键字都在叶子结点出现；

​    如：（M=3）

![图片](https://mmbiz.qpic.cn/mmbiz_png/viaxzHeHib8eibFvME0ic7AEWvZEOib58ddicuTfmwNicylfx8TJGgclTg4vvickyb1bdFGWxNoicRJia8JSMH1gsfBcXkFQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

###### B+树算法思想

​    B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；   

B+树的特性       

​	1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
​	2.不可能在非叶子结点命中；
​	3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
​	4.更适合文件索引系统；    

###### 算法实现

```python
# -*- coding: UTF-8 -*-
# B树查找

class BTree:  #B树
    def __init__(self,value):
        self.left=None
        self.data=value
        self.right=None

    def insertLeft(self,value):
        self.left=BTree(value)
        return self.left

    def insertRight(self,value):
        self.right=BTree(value)
        return self.right

    def show(self):
        print(self.data)


def inorder(node):  #中序遍历：先左子树，再根节点，再右子树
    if node.data:
        if node.left:
            inorder(node.left)
        node.show()
        if node.right:
            inorder(node.right)


def rinorder(node):  #倒中序遍历
    if node.data:
        if node.right:
            rinorder(node.right)
        node.show()
        if node.left:
            rinorder(node.left)

def insert(node,value):
    if value > node.data:
        if node.right:
            insert(node.right,value)
        else:
            node.insertRight(value)
    else:
        if node.left:
            insert(node.left,value)
        else:
            node.insertLeft(value)


if __name__ == "__main__":

    l=[88,11,2,33,22,4,55,33,221,34]
    Root=BTree(l[0])
    node=Root
    for i in range(1,len(l)):
        insert(Root,l[i])

    print("中序遍历（从小到大排序 ）")
    inorder(Root)
    print("倒中序遍历（从大到小排序）")
    rinorder(Root)
```

##### 5. 树表查找总结 　

​		二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。

​		在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。 　　

​	除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。



---

### 1.1.9 图（Graph）

​		图是数据结构和算法学中最强大的框架之一（或许没有之一）。图几乎可以用来表现所有类型的结构或系统，从交通网络到通信网络，从下棋游戏到最优流程，从任务分配到人际交互网络，图都有广阔的用武之地。

**图的定义**：
一个图是一个二元组（V，E），其中：
	1）V是一个非空有穷的顶点集合
	2）E是顶点偶对（称为边）的集合
	3）V中的顶点也称为图G的顶点，E中的边也称为图G的边

**基本属性**：
	1）图分为有向图和无向图两种，有向图的边有方向，是顶点的有序对；无向图中的边没有方向，是顶点的无序对
	2）一个顶点的度就是与它邻接的边的条数，对于有向图，顶点的度还分为入度和出度，分别表示以该顶点为终点或者始点的边的条数
	3）如果在有向图G里存在一个顶点v，从顶点v到图G中其他每个顶点均有路径，则称G为有根图，称顶点v为图G的一个根
	4）连通无向图：如果无向图G中任意两个顶点vi与vj之间都连通，则称G为连通无向图；强连通有向图：如果对有向图G中任意两个顶点vi和vj，从vi到vj以及从vj到vi都有路径，则称G为强连通有向图
	5）如果图G中的每条边都被赋予一个权值，则称G为一个带权图。边的权值可用于表示实际应用中与顶点之间的关联有关的某些信息。带权的连通无向图也被称为网络

**术语表：**

* 顶点 Vertex（也“节点node”）
  是图的基本组成部分，定点具有名称标识key，也可以携带数据项payload。
* 边 Edge（也称“弧Arc”）
  作为2个顶点之间关系的表示，边连接两个顶点；边可以是有向的或者无向的，相应的图称做“有向图”和“无向图”。
* 权重 Weight
  为了表达从一个顶点到另一个顶点的“代价”，可以给边赋权；例如公交网络中两个站点之间的“距离”、“通行时间”和“票价”都可以作为权重。
* 路径Path
  图中的路径，是由边依次链接起来的顶点序列；无权路径的长度为边的数量；带权路径的长度为所有边权重的和；如下图的一条路径(v3,v4,v0,v1)
* 圈Cycle
  圈是首尾顶点相同的路径，如下图中（V5,V2,V3,V5）
  如果有向图中不存在任何圈，则称为“有向无圈图 directed acyclic graph：DAG”
  如果一个问题能表示成DAG，就可以用图算法很好地解决。
  ![img](https://img-blog.csdnimg.cn/20200309134016151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dkOWxqczE4,size_16,color_FFFFFF,t_70)

#### 抽象数据类型：ADT Graph[^2]

##### 定义

Graph()									  			 创建一个空图
addVertex(vert)									 将顶点vert加入图中
addEdge(fromVert, toVert)				  添加有向边
addEdge(fromVert, toVert, weight)	添加带权的有向边
getVertex(vKey)	                                 查找名称为vKey的顶点
getVertices()	                                       返回图中所有顶点列表
in	                                                          按照vert in graph的语句形式，返回顶点是否存在图中True/False

##### ADT Graph的实现方法

两种方法各有优劣，需要在不同应用中加以选择

- 邻接矩阵adjacency matrix

- 邻接表adjacency list

###### 邻接矩阵Adjacency Matrix

矩阵的每行和每列都代表图中的顶点，如果两个顶点之间有边相连，设定行列值

- 无权边则将矩阵分量标注为1，或者0

- 带权边则将权重保存为矩阵分量值

例如下面的带权图：

<img src="https://img-blog.csdnimg.cn/20200309134541250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dkOWxqczE4,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />


邻接矩阵顶实现法的优点是简单，可以很容易得到顶点是如何相连
但如果图中的边数很少则效率低下，成为“稀疏sparse”矩阵，而大多数问题所对应的图都是稀疏的，边远远少于|V|2这个量级，从而出现邻接列表。

**算法实现:**

```python
inf = float('inf')  #定义一个无穷大的量表示无边情况

#采用邻接矩阵实现
class Graph:
    def __init__(self,mat,unconn = 0):   #初始化
        vnum = len(mat)
        for x in mat:
            if len(x) != vnum:
                raise ValueError("Argument for 'Graph'.")
        self._mat = [mat[i][:] for i in range(vnum)]      #使用拷贝的数据
        self._unonn = unconn
        self._vnum = vnum
        
    def vertex_num(self):      #返回结点数目
        return self._vnum
    
    def _invalid(self,v):      #检验输入的结点是否合法
        return v > 0 or v >= self._vnum
    
    def add_adge(self,vi,vj,val=1):   #增加边
        if self._invalid(vi) or self._invalid(vj):
            raise GraphError(str(vi) + ' or' + str(vj) + 'is not a valid vertex.')
        self._mat[vi][vj] = val
        
    def get_adge(self,vi,vj):   #得到边的信息
        if self._invalid(vi) or self._invalid(vj):
            raise GraphError(str(vi) + ' or' + str(vj) + 'is not a valid vertex.')
        return self._mat[vi][vj]
        
    def out_edges(self,vi):    #得到vi出发的所有边
        if self._invalid(vi):
            raise GraphError(str(vi)+' is not a valid vertex.')
        return self._out_edges(self._mat[vi],self._unconn)
    
    @staticmethod
    def _out_edges(row,unconn): #辅助函数
        edges = []
        for i in range(len(row)):
            if row[i] != unconn:
                edges.append((i,row[i]))
        return edges
    
    def __str__(self):          #输出的str方法
        return '[\n' + ',\n'.join(map(str,self._mat)) + '\n]' + '\nUnconnected: ' + str(self._unconn)
```

###### 邻接列表Adjacency List

* 邻接列表可以成为稀疏图的更高效实现方案
  维护一个包含所有顶点的主列表（master list）。主列表中的每个顶点，再关联一个与自身由边链接的所有顶点的列表。

* 邻接列表法的寻出空间紧凑高效
  很容易获得顶点所连接的所有顶点以及边的信息

例如上面的图转为邻接列表，与V0有关的有V1和V5，权重分别是5和2：

<img src="https://img-blog.csdnimg.cn/20200309140020972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dkOWxqczE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

**算法实现:**

```python
#采用邻接表实现，需要重写一些方法，但功能相同
class GraphAL(Graph):      #继承于Graph
    def __init__(self,mat=[],unconn=0):
        vnum = len(mat)
        for x in mat:
            if len(x) !=vnum:
                raise ValueError("Argument for 'Graph'.")
        self._mat = [Graph._out_edges(mat[i],unconn) for i in range(vnum)]
        self._vnum = vnum
        self._unconn = unconn
        
    def add_edge(self,vi,vj,val = 1):
        if self._vnum == 0:
            raise GraphError('Cannot add edge to empty graph.')
        if self._invalid(vi) or self._invalid(vj):
            raise GraphError(str(vi) + ' or' + str(vj) + ' is not valid vertex.')
            
        row = self._mat[vi]
        i = 0
        while i < len(row):
            if row[i][0] == vj:
                self._mat[vi][i] = (vj,val)
                return
            if row[i][0] > vj:
                break
            i += 1
        self._mat[vi].insert(i,(vj,val))
        
    def get_edge(self,vi,vj):
        if self._invalid(vi) or self._invalid(vj):
            raise GraphError(str(vi) + ' or' + str(vj) + ' is not valid vertex.')
        for i,val in self._mat[vi]:
            if i == vj:
                return val
        return self._unconn
    
    def out_edges(self,vi):
        if self._invalid(vi):
            raise GraphError(str(vi) + ' is not valid vertex.')
        
        return self._mat[vi]
```

##### ADT Graph的代码实现

###### Vertex类

下面展示了 **Vertex** 类的代码，包含了顶点信息， 以及顶点连接边信息

**算法实现:**

```python
class Vertex:
    def __init__(self,key):
        self.id = key
        self.connectedTo = {}
	#从这个顶点添加一个连接到另一个
    def addNeighbor(self,nbr,weight=0):  #nbr是顶点对象的key
        self.connectedTo[nbr] = weight
	#顶点数据字符串化，方便打印
    def __str__(self):
        return str(self.id) + ' connectedTo: ' + str([x.id for x in self.connectedTo])
	#返回邻接表中的所有顶点
    def getConnections(self):
        return self.connectedTo.keys()
	#返回key
    def getId(self):
        return self.id
	#返回顶点边的权重。
    def getWeight(self,nbr):
        return self.connectedTo[nbr]
```

###### Graph 类

Graph 类的代码，包含将顶点名称映射到顶点对象的字典。
Graph 还提供了将顶点添加到图并将一个顶点连接到另一个顶点的方法。
getVertices方法返回图中所有顶点的名称。
此外，我们实现了iter 方法，以便轻松地遍历特定图中的所有顶点对象。 这两种方法允许通过名称或对象本身在图形中的顶点上进行迭代。

**算法实现:**

```python
class Graph:
    def __init__(self):
        self.vertList = {}
        self.numVertices = 0
	#新加顶点
    def addVertex(self,key):
        self.numVertices = self.numVertices + 1
        newVertex = Vertex(key)
        self.vertList[key] = newVertex
        return newVertex
	#通过key查找顶点
    def getVertex(self,n):
        if n in self.vertList:
            return self.vertList[n]
        else:
            return None

    def __contains__(self,n):
        return n in self.vertList
   
    def addEdge(self,f,t,cost=0):
        if f not in self.vertList: #不存在的顶点先添加
            nv = self.addVertex(f)
        if t not in self.vertList:
            nv = self.addVertex(t)
        self.vertList[f].addNeighbor(self.vertList[t], cost)

    def getVertices(self):
        return self.vertList.keys()

    def __iter__(self):
        return iter(self.vertList.values())
```

#### 图的搜索

  回溯法(探索与回溯法)是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

##### 深度优先搜索(DFS)

深度优先搜索（Depth_Fisrst Search）遍历类似于树的先根遍历，是树的先根遍历的推广。

**深度优先搜索实现步骤：**
（1）访问初始顶点v并标记顶点v已访问。
（2）查找顶点v的第一个邻接顶点w。
（3）若顶点v的邻接顶点w存在，则继续执行；否则回溯到v，再找v的另外一个未访问过的邻接点。
（4）若顶点w尚未被访问，则访问顶点w并标记顶点w为已访问。
（5）继续查找顶点w的下一个邻接顶点wi，如果v取值wi转到步骤（3）。直到连通图中所有顶点全部访问过为止

假设初始状态是图中所有顶点未曾被访问，则深度优先搜索可从图中某个顶点发v 出发，访问此顶点，然后依次从v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和v 有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。

以如下图的无向图G5为例，进行图的深度优先搜索：

<img src="https://www.pianshen.com/images/301/f7f3381875d4fb89a51edbedd07b4d05.JPEG" alt="img" style="zoom:67%;" />

**深度优先搜索过程：**

<img src="https://www.pianshen.com/images/651/233c2b67d9d21ada5187ef66e23e8c13.JPEG" alt="img" style="zoom:67%;" />



假设从顶点v1 出发进行搜索，在访问了顶点v1 之后，选择邻接点v2。因为v2 未曾访问，则从v2 出发进行搜索。依次类推，接着从v4 、v8 、v5 出发进行搜索。在访问了v5 之后，由于v5 的邻接点都已被访问，则搜索回到v8。由于同样的理由，搜索继续回到v4，v2 直至v1，此时由于v1 的另一个邻接点未被访问，则搜索又从v1 到v3，再继续进行下去由此，得到的顶点访问序列为：

<img src="https://www.pianshen.com/images/784/bf779a31f20b7da767f7fcb3e765ee78.JPEG" alt="img" style="zoom:80%;" />

显然，这是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组visited[0:n-1], ，其初值为FALSE ，一旦某个顶点被访问，则其相应的分量置为TRUE。

**算法实现:**

```python
from pythonds.graphs import Graph
class DFSGraph(Graph):
    def __init__(self):
        super().__init__()
        self.time = 0
 
    def dfs(self):
        for aVertex in self:
            aVertex.setColor('white')
            aVertex.setPred(-1)
        for aVertex in self:
            if aVertex.getColor() == 'white':
                self.dfsvisit(aVertex)
 
    def dfsvisit(self,startVertex):
        startVertex.setColor('gray')
        self.time += 1
        startVertex.setDiscovery(self.time)
        for nextVertex in startVertex.getConnections():
            if nextVertex.getColor() == 'white':
                nextVertex.setPred(startVertex)
                self.dfsvisit(nextVertex)
        startVertex.setColor('black')
        self.time += 1
		startVertex.setFinish(self.time)
```

##### 广度优先搜索(BFS)

广度优先搜索（Breadth_First Search） 遍历类似于树的按层次遍历的过程。

**广度优先实现步骤：**
（1）顶点v入队列。
（2）当队列非空时则继续执行，否则算法结束。
（3）出队列取得队头顶点v；访问顶点v并标记顶点v已被访问。
（4）查找顶点v的第一个邻接顶点col。
（5）若v的邻接顶点col未被访问过的，则col入队列。
（6）继续查找顶点v的另一个新的邻接顶点col，转到步骤（5）。直到顶点v的所有未被访问过的邻接点处理完。转到步骤（2）。

假设从图中某顶点v 出发，在访问了v 之后依次访问v 的各个未曾访问过和邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问，直至图中所有已被访问的顶点的邻接点都被访问到。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。换句话说，广度优先搜索遍历图的过程中以v 为起始点，由近至远，依次访问和v 有路径相通且路径长度为1,2,…的顶点。

对图如下图所示无向图G5 进行广度优先搜索遍历：

<img src="https://www.pianshen.com/images/301/f7f3381875d4fb89a51edbedd07b4d05.JPEG" alt="img" style="zoom:67%;" />



**广度优先搜索过程：**

<img src="https://www.pianshen.com/images/955/4daf88968856c3e32eae6b9d854315cb.JPEG" alt="img" style="zoom:67%;" />

首先访问v1 和v1 的邻接点v2 和v3，然后依次访问v2 的邻接点v4 和v5 及v3 的邻接点v6 和v7，最后访问v4 的邻接点v8。由于这些顶点的邻接点均已被访问，并且图中所有顶点都被访问，由些完成了图的遍历。得到的顶点访问序列为：

​				v1→v2 →v3 →v4→ v5→ v6→ v7 →v8


和深度优先搜索类似，在遍历的过程中也需要一个访问标志数组。并且，为了顺次访问路径长度为2、3、…的顶点，需附设队列以存储已被访问的路径长度为1、2、… 的顶点。

**算法实现:**

```python
from pythonds.graphs import Graph, Vertex
from pythonds.basic import Queue
 
def bfs(g,start):
  start.setDistance(0)
  start.setPred(None)
  vertQueue = Queue()
  vertQueue.enqueue(start)
  while (vertQueue.size() > 0):
    currentVert = vertQueue.dequeue()
    for nbr in currentVert.getConnections():
      if (nbr.getColor() == 'white'):
        nbr.setColor('gray')
        nbr.setDistance(currentVert.getDistance() + 1)
        nbr.setPred(currentVert)
        vertQueue.enqueue(nbr)
	currentVert.setColor('black')
```

#### 图的简单应用

图是实际中经常运用到的数据结构，这里列举出两个经典的问题，给出解决算法。[^1]

##### 最小生成树解法

假定G是一个网络，其中的边带有给定的权值，可以做出它的生成树，现将G的一棵生成树中各条边的权值之和称为该生成树的权。网络G可能存在许多棵不同的生成树，不同生成树的权值也有可能不同，其中权值最小的生成树称为G的最小生成树

###### Kruskal算法

Kruskal算法是一种构造最小生成树的简单算法，其中的思想也比较简单
算法思想：
（1）设G = （V，E）是一个网络，其中|V| = n。初始时取包含G中所有n个顶点但没有任何边的孤立点子图T= (V,{}),T里的每一个顶点自成一个连通分量
（2）将边集E中的边按权值递增的顺序排列，在构造中的每一步顺序地检查这个边序列，找到下一条（最短的）两端点位于T的两个不同连通分量的边e，把e加入T。这导致两个连通分量由于边e的连接而变成了一个连通分量
（3）每次操作使T减少一个连通分量，不断重复这个动作加入新边，直到T中所有顶点都包含在一个连通分量里为止，这个连通分量就是G的一棵最小生成树

此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。

1. 把图中的所有边按代价从小到大排序；
2. 把图中的n个顶点看成独立的n棵树组成的森林；
3. 按权值从小到大选择边，所选的边连接的两个顶点ui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。
4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。

**算法实现:**

```python
#Krudkal最小生成树算法
def Kruskal(graph):
    vnum = graph.vertex_num()
    reps = [i for i in range(vnum)]
    mst,edges = [],[]
    for vi in range(vnum):  #所有边入表
        for v,w in graph.out_edges(vi):
            edges.append((w,vi,v))
    edges.sort()            #按权值排序
    for w,vi,vj in edges:
        if reps[vi] != reps[vj]:
            mst.append((vi,vj),w)
            if len(mst) == vnum - 1:
                break
            rep,orep = rep[vi],reps[vj]
            for i in range(vnum):  #合并连通分量
                if reps[i] == orep:
                    reps[i] = rep
    return mst
```

###### Prim算法

Prim算法基于最小生成树的一个重要性质，MST性质如下：
设G=（V，E）是一个网络，U是V的一个任意真子集，e为G的一条边，一个端点在U里，另一个不在，而且e的权值与其他同情况的边相比最小，那么G必有一棵包括边e的最小生成树
算法思想：
（1）从图G的顶点集V中任取一顶点放入集合U中，这时U = {v0},令边集合ET = {},显然T=（U，ET）是一棵树
（2）检查所有一个端点在集合U里而另一个端点在集合V-U的边，找出其中权最小的边，将不再U的顶点加入，并将e加入边集合ET
（3）重复步骤（2）直到U=V，这时子图T就是G的一棵最小生成树

此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。

1. 图的所有顶点集合为V；初始令集合u={s},v=V−u;
2. 在两个集合u,v能够组成的边中，选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中。
3. 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。

由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge,用来维护集合v中每个顶点与集合u中最小代价边信息。

**算法实现：**

```python
class PrioQueueError(ValueError):
    pass
    
#使用list实现基于堆的优先序列
（这是额外的内容，帮助Prim算法的实现）
class PrioQueue:
    def __init__(self,elist=[]):
        self._elems = list(elist)
        if elist:
            self.buildheap()
    
    def is_empty(self):
        return not self._elems
            
    def enqueue(self,e):
        self._elems.append(None)
        self.siftup(e,len(self._elems)-1)
        
    def siftup(self,e,last):
        elems,i,j = self._elems,last,(last-1)//2
        while i > 0 and e < elems[j]:
            elems[i] = elems[j]
            i,j, = j,(j-1)//2
        elems[i] = e
        
    def dequeue(self):
        if self.is_empty():
            raise PrioQueueError('in dequeue')
        elems = self._elems
        e0 = elems[0]
        e = elems.pop()
        if len(elems) > 0:
            self.siftdown(e,0,len(elems))
        return e0
    
    def siftdown(self,e,begin,end):
        elems,i,j = self._elems,begin,begin*2+1
        while j < end:
            if j+1 < end and elems[j+1] < elems[j]:
                j += 1
            if e < elems[j]:
                break
            elems[i] = elems[j]
            i,j = j,2*j+1
        elems[i] = e
    
    def buildheap(self):
        end = len(self._elems)
        for i in range(end//2.-1,-1):
            self.siftdown(self._elems[i],i,end)          

#Prim最小生成树法
def Prim(graph):
    vnum = graph.vertex_num()
    mst = [None]*vnum
    cands = PrioQueue([(0,0,0)])
    count = 0
    while count < vnum and not cands.is_empty():
        w,u,v = cands.dequeue()
        if mst[v]:
            continue
        mst[v] = ((u,v),w)
        count += 1
        for vi,w in graph.out_edges(v):
            if not mst[vi]:
                cands.enqueue((w,v,vi))
    return mst
```

##### 最短路径问题

最短路径问题可以分为两种：

* 单源最短路径问题，即从一个顶点出发到图中其余各顶点的最短路径问题；
* 所有顶点之间的最短路径问题

###### 单源最短路径的Dijkstra算法

- 算法特点：

  迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。

- 算法的思路

  Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。
  然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，
  然后，需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。
  然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。
  **算法实现:**

```python
import PrioQueue

#Dijkstra算法
def dijkstra_shortest_paths(graph,v0):
    vnum = graph.vertex_num()
    assert 0 <= v0 <= vnum
    paths = [None]*vnum
    count = 0
    cands = PrioQueue([(0,v0,v0)])     #初始队列
    while count < vnum and not cands.is_empty():
        plen,u,vmin = cands.dequeue()  #取顶点
        if paths[vmin]:
            continue
        paths[vmin] = (u,plen)         #记录路径
        for v,w in graph.out_edges(vmin):
            if not paths[v]:
                cands.enqueue((plen + w,vmin,v))
        count += 1
    return paths
```

###### 任意顶点间最短路径的Floyd算法

- 算法的特点：
  弗洛伊德算法是解决任意两点间的最短路径的一种算法，可以正确处理有向图或有向图或负权（但不可存在负权回路)的最短路径问题，同时也被用于计算有向图的传递闭包。
- 算法的思路

通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入两个矩阵，矩阵S中的元素a\[i]\[j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。矩阵P中的元素b\[i]\[j]，表示顶点i到顶点j经过了b\[i]\[j]记录的值所表示的顶点。

假设图G中顶点个数为N，则需要对矩阵D和矩阵P进行N次更新。初始时，矩阵D中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a\[i]\[j]=∞，矩阵P的值为顶点b\[i]\[j]的j的值。 接下来开始，对矩阵D进行N次更新。第1次更新时，如果”a\[i]\[j]的距离” > “a\[i]\[0]+a\[0]\[j]”(a\[i]\[0]+a\[0]\[j]表示”i与j之间经过第1个顶点的距离”)，则更新a\[i]\[j]为”a\[i]\[0]+a\[0]\[j]”,更新b\[i]\[j]=b\[i]\[0]。 同理，第k次更新时，如果”a\[i]\[j]的距离” > “a\[i]\[k-1]+a\[k-1]\[j]”，则更新a\[i]\[j]为”a\[i]\[k-1]+a\[k-1]\[j]”,b\[i]\[j]=b\[i]\[k-1]。更新N次之后，操作完成！
**算法实现:**

```python
def all_shortest_paths(graph):
    vnum = graph.vertex_num()
    a = [[graph.get_edge(i,j) for j in range(vnum)] for i in range(vnum)]
    nvertex = [[-1 if a[i][j] == inf else j for j in range(vnum)] for i in range(vnum)]
    
    for k in range(vnum):
        for i in range(vnum):
            for j in range(vnum):
                if a[i][j] > a[i][k] + a[k][j]:
                    a[i][j] = a[i][k] + a[k][k]
                    nevertex[i][j] = nevertex[i][k]
    return (a,nevertex)
```



#### Reference

---

[^1]: https://www.pianshen.com/article/59711034263/
[^2]: https://blog.csdn.net/wd9ljs18/article/details/112191078

